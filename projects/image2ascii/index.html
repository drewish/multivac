---
layout: full_width
title: Image to ASCII
---

<div class="row">
  <div class="small-8 columns">
    <label for="file">File</label>
    <input type="file" id="file" onchange="handleFileSelection(this.files)">
  </div>
  <div class="small-2 columns">
    <label for="height">Height</label>
    <input type="number" min="1" id="height" size="60" value="60">
  </div>
  <div class="small-2 columns">
    <label for="width">Width</label>
    <input type="number" min="1" id="width" size="60" value="60">
  </div>
</div>

<div class="row">
  <canvas id="canvas" class="large-12 columns" width="250px" height="150px" style="border: 1px solid pink"></canvas>
</div>

<div class="row">
  <pre id="output" class="large-12 columns" style='font-family: "Consolas", "Menlo", "Courier", monospace;'></pre>
</div>

<script type="text/javascript">

  function handleFileSelection(files) {
    console.log(files);
    reader = new FileReader();
    reader.onload = function(event) {
      var image = new Image();
      image.onload = function(event) {
        drawCanvas(event.srcElement);
      }
      image.src = event.target.result;
    };
    reader.readAsDataURL(files[0]);
  }

  function drawCanvas(image) {
    var canvas = document.getElementById('canvas')
      , context = canvas.getContext('2d')
      , height = document.getElementById('height').value * 2
      , width = document.getElementById('width').value * 2;

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.drawImage(image, 0, 0, width, height);

    // Convert the scaled image into a gray scale pixels array.
    var data = context.getImageData(0, 0, width, height).data;
    var offset, red, green, blue, alpha, brightness;
    var pixels = [];
    for (var y = 0; y < height; y++) {
      pixels[y] = [];
      for (var x = 0; x < width; x++) {
        offset = (y * width + x) * 4;
        red   = data[offset];
        green = data[offset + 1];
        blue  = data[offset + 2];
        alpha = data[offset + 3];
        brightness = (0.3 * red + 0.59 * green + 0.11 * blue) / 255;
        pixels[y][x] = brightness;
      }
    }

    // Apply Floyd–Steinberg dithering
    // http://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering
    for (var y = 0; y < height; y += 1) {
      for (var x = 0; x < width; x += 1) {
        var oldpixel    = pixels[y][x]
          , newpixel    = Math.round(oldpixel)
          , quant_error = oldpixel - newpixel;
        pixels[y][x] = newpixel;
        if (x + 1 < width) {
          pixels[y  ][x+1] = pixels[y  ][x+1] + 7/16 * quant_error;
        }
        if (y + 1 < height) {
          pixels[y+1][x-1] = pixels[y+1][x-1] + 3/16 * quant_error;
          pixels[y+1][x  ] = pixels[y+1][x  ] + 5/16 * quant_error;
          pixels[y+1][x+1] = pixels[y+1][x+1] + 1/16 * quant_error;
        }
      }
    }

    /*
      Each character represents a rectangle of 4 black or white pixels:
        qr
        st
      There are 16 possible combinations of and we have 16 different Unicode
      characters to represent them. To keep the references orderly I assigned each
      pixel a power of two:
        12
        48
      So adding up the values that are on gives you the index of the character in this
      list:
        0123456789ABCDEF
        █▟▙▄▜▐▚▗▛▞▌▖▀▝▘
      For example:
        12
        _8 sums to 11 (B) giving "▖"

        1_
        4_ sums to 5 giving "▐"
    */
    var characters = "█▟▙▄▜▐▚▗▛▞▌▖▀▝▘ ".split('').reverse();
    var characterPosition, brightnessPosition, thisChar;
    var q , r , s , t;
    var strChars = "<!--\n";
    for (var y = 0; y < height; y += 2) {
      for (var x = 0; x < width; x += 2) {
        q = 1 * Math.round(1 - pixels[y][x]);
        r = 2 * Math.round(1 - pixels[y][x + 1]);
        s = 4 * Math.round(1 - pixels[y + 1][x]);
        t = 8 * Math.round(1 - pixels[y + 1][x + 1]);
        strChars += characters[q + r + s + t];
      }
      strChars += "\n";
    }
    strChars += "-->";

    document.getElementById("output").textContent = strChars;
  }
</script>